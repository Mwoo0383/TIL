# 1단원 - 요구사항 확인

## 📌 애자일(Agile) 방법론
> - 절차보다는 사람 중심이 되어 변화에 유연한 신속 적응적 경량 개발 방법론
> - 개발 기간이 짧고 신속하며, 폭포수 모델에 대비되는 방법론

## 📌 럼바우 데이터 모델링
> 1. **객체(Object) 모델링 = 정보 모델링**  
: 시스템에서 요구하는 객체를 찾고 객체 간의 관계를 정의하여 ER 다이어그램을 만드는 과정까지의 모델링. 객체 다이어그램을 활용하여 표현
> 2. **동적(Dynamic) 모델링**  
: 시간의 흐름에 따라 객체들 사이의 제어 흐름, 동작 순서 등의 동적인 행위를 표현하는 모델링. 상태 다이어그램을 활용하여 표현
> 3. **기능(Functional) 모델링**  
: 프로세스들의 자료 흐름을 중심으로 처리 과정을 표현하는 모델링. 자료 흐름도를 활용하여 표현

## 📌 객체 지향 설계 원칙(SOLID)
> 1. **단일 책임의 원칙(SRP : Single Responsibility Principle)**  
: 하나의 클래스는 하나의 목적을 위해서 생성. 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중되어 있어야 함
> 2. **개방 폐쇄의 원칙(OCP : Open Close Principle)**  
: 소프트웨어 구성 요소는 확장에 열려 있고, 변경에는 닫혀 있어야 함
> 3. **리스코프 치환의 원칙(LSP : Liskov Substitution Principle)**  
: 자식은 어디서나 부모로 교체할 수 있어야 함
> 4. **인터페이스 분리의 원칙(ISP : Interface Segregation Principle)**  
: 한 클래스는 자신이 사용하지 않는 인터페이스에 의존하지 않아야 함.
> 5. **의존성 역전의 법칙(DIP : Dependency Inversion Principle)**  
: 추상을 매개로 메세지를 주고받음으로써 관계를 느슨하게 만드는 원칙

## 📌 목적에 따른 디자인 패턴 유형
> 1. **생성**  
: 객체 인스턴스 생성에 관여, 클래스의 정의와 객체 생성 방식을 구조화, 캡슐화를 수행하는 패턴
> 2. **구조**  
: 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴
> 3. **행위**  
: 클래스나 객체들의 상호 작용하는 방법과 역할 분담을 다루는 패턴

## 📌 GoF 디자인 패턴 종류

### 1. 생성 패턴 
> - **Builder**  
: 복잡한 인스턴스를 ***조립***하여 만드는 구조, 생성과 표기를 분리해 복잡한 객체를 생성
> - **Prototype**  
: 원본을 ***복사***한 후 필요한 부분만 수정하여 사용
> - **Factory Method**  
: 상위 클래스에서 인터페이스 정의, 하위 클래스에서 인터페이스 생성
> - **Abstract Factory**  
: 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공, 동일한 주제의 다른 팩토리를 묶음
> - **Singleton**  
: 한 클래스에 한 객체만 존재하도록 제한

### 2. 구조 패턴
> - **Bridge**  
: 기능의 클래스 계층과 구현의 클래스 계층을 연결
> - **Decorator**  
: 기존 클래스에 ***필요한 기능을 추가해*** 나가는 설계 패턴 상속의 대안으로 사용
> - **Facade**  
: 복잡한 시스템에 대하여 단순한 인터페이스를 제공함으로써 시스템 구조에 대한 파악을 쉽게 할 수 있음
> - **Flyweight**  
: 여러 개의 '가상 인스턴스'를 제공하여 메모리 절감 ***클래스의 경량화를 목적***으로 함
> - **Proxy**  
: ***실체 객체에 대한 대리 객체.*** 정보 은닉, 메모리 용량 절약
> - **Composite**  
: 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현
> - **Adapter**  
: 기존에 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰즈는 역할을 하는 인터페이스

### 3. 행위 패턴
> - **Mediator**  
: 중재자를 두고, 중재자에게 모든 걸 요구하여 통신의 빈도수를 줄임
> - **InterPreter**  
: 분리된 구문의 해석을 맡는 클래스를 각각 작성
> - **Iterator**  
: 복잡 객체의 원소를 순차적으로 접근 가능하게 해줌
> - **Template Method**  
: 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꿈
> - **Observer**  
: 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방법을 제공
> - **State**  
: 객체의 상태를 캡슐화하여 클래스화함으로써 그것을 참조하게 하는 방식
> - **Visitor**  
: 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만듬
> - **Command**  
: 재사용성이 높은 클래스를 설계하는 패턴. 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행
> - **Strategy**  
: 같은 알고리즘을 하나의 클래스로 캡슐화 한 뒤, 필요할 때 서로 교환해서 쓸 수 있게 함
> - **Memento**  
: 객체를 이전 상태로 복구 시켜야 하는 경우, undo 요청
> - **Chain of Responsibility**  
: 하드 코딩을 동적으로 연결되게 처리

## 📌 요구사항의 분류

### 1. 기능 요구사항  
: 시스템이 제공하는 기능, 서비스에 대한 요구사항
### 2. 비기능 요구사항  
: 시스템이 수행하는 기능 이외의 사항, 시스템 구축에 대한 제약사항에 관한 요구사항