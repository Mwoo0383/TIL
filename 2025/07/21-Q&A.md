# ⁉️ Q&A

## 싱글턴 패턴이란 무엇인가요 ?

> - 생성자를 여러차례 호출해도 실제로 생성되는 객체를 하나로 유지하는 것을 의미
> - 객체가 최초로 생성된 이후에 생성자나 객체 생성 메서드는 기존에 만들어진 객체를 반환

### 싱글턴 패턴의 장단점은 무엇인가요 ?
- 하나의 객체를 여러 상황에서 재사용할 수 있기 때문에 **메모리 낭비를 방지**
- 여러 스레드가 동시에 생성자에 접근하면 두 개 이상의 객체가 생성될 수 있으므로 **동시성 문제**를 고려해야 함
- 테스트 시 매번 객체의 상태를 초기화해줘야 하는 불편함이 있음

## 쿠키와 세션의 차이를 설명해주세요.
> - 쿠키와 세션은 HTTP의 무상태(stateless) 특성을 보완하여 사용자 상태를 유지하는 매커니즘

| 항목         | **쿠키 (Cookie)**                      | **세션 (Session)**                              |
| ---------- | ------------------------------------ | --------------------------------------------- |
| **저장 위치**  | 클라이언트(브라우저)에 저장                      | 서버에 저장 (세션 ID만 쿠키로 클라이언트에 전달됨)                |
| **보안성**    | 클라이언트에 저장 → 사용자가 조작 가능 → **보안에 취약**  | 서버에 저장 → **상대적으로 안전**                         |
| **용량 제한**  | 도메인당 약 **4KB** 제한                    | 제한 없음 (서버 리소스에 의존)                            |
| **라이프사이클** | 설정된 **만료 시간까지 유지** or 브라우저 종료 시 삭제   | **일정 시간 요청 없으면 자동 만료** (서버 설정에 따라 다름)         |
| **성능 영향**  | 매 요청마다 함께 전송 → **네트워크 트래픽 증가**       | 서버 메모리 사용 → **사용자 수 많아질수록 서버 부하 증가**          |
| **사용 용도**  | 사용자 선호 설정, 비로그인 상태 장바구니 등 **비민감 정보** | 로그인 정보 등 **중요 데이터**                           |
| **기타**     | 설정과 삭제가 비교적 간단                       | 유지/만료 관리는 서버 측 로직 필요                          |
| **대체 기술**  | —                                    | **JWT (JSON Web Token)** 등 토큰 기반 인증 방식으로 대체 중 |

## Spring에서 객체를 Bean으로 관리하는 이유를 설명해주세요.
> - 애플리케이션의 설계, 확장성, 유지보수 측면에서 많은 이점을 제공

### 1. 의존성 관리 자동화
- Spring 컨테이너(BeanFactory, ApplicationContext)가 자동으로 의존성 주입
- 컨테이너가 빌드 시점에 순환 의존성을 감지하여 설계 오류를 조기에 발견 가능

### 2. 싱글톤 패턴 구현
- 메모리 사용 최적화, 불필요한 객체 생성 방지

### 3. 생명주기 관리
- Spring은 빈의 초기화와 소멸 과정을 자동으로 관리, 이를 통해 리소스 할당 및 해제를 체계적으로 관리 가능

### 4. AOP 지원
### 5. 테스트 용이성
### 6. 설정의 중앙화